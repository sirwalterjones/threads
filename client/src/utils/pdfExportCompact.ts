import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { Post } from '../types';

interface PostWithComments extends Post {
  comments?: Array<{
    content: string;
    author_name?: string;
    username?: string;
    created_at?: string;
  }>;
}

// Extend jsPDF types
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
    lastAutoTable: {
      finalY: number;
    };
    previousAutoTable?: {
      finalY: number;
    };
  }
}

interface ImageInfo {
  width: number;
  height: number;
  data: string;
}

// Cache for loaded images
const imageCache: Map<string, ImageInfo> = new Map();

export const generatePDF = async (posts: PostWithComments[], options: { includeComments?: boolean; includeTags?: boolean; user?: { username?: string; email?: string } } = {}) => {
  const doc = new jsPDF();
  
  // Professional color scheme
  const black: [number, number, number] = [0, 0, 0];
  const white: [number, number, number] = [255, 255, 255];
  const darkGray: [number, number, number] = [51, 51, 51];
  const mediumGray: [number, number, number] = [102, 102, 102];
  const lightGray: [number, number, number] = [240, 240, 240];
  const accentBlue: [number, number, number] = [0, 123, 255];
  
  // Add compact header for first page
  const addCompactHeader = (pageNum: number = 1) => {
    doc.setFillColor(black[0], black[1], black[2]);
    doc.rect(0, 0, 210, 15, 'F');
    
    doc.setTextColor(white[0], white[1], white[2]);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('VECTOR', 10, 10);
    
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.text(`Page ${pageNum}`, 200, 10, { align: 'right' });
  };
  
  // First page header
  addCompactHeader();
  
  // Document info
  doc.setTextColor(darkGray[0], darkGray[1], darkGray[2]);
  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  const generatedBy = options.user?.username || options.user?.email || 'Unknown User';
  const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  doc.text(`Generated by ${generatedBy} on ${date}`, 10, 20);
  doc.text(`${posts.length} ${posts.length === 1 ? 'Post' : 'Posts'}`, 10, 25);
  
  // Table of Contents
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('Table of Contents', 10, 35);
  
  let tocY = 42;
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  
  posts.forEach((post, index) => {
    if (tocY > 280) {
      doc.addPage();
      addCompactHeader(doc.getNumberOfPages());
      tocY = 25;
    }
    
    const pageNum = index + 2;
    const title = post.title || 'Untitled Post';
    const truncatedTitle = title.length > 85 ? title.substring(0, 82) + '...' : title;
    
    doc.setTextColor(mediumGray[0], mediumGray[1], mediumGray[2]);
    doc.text(`${pageNum}.`, 15, tocY);
    doc.setTextColor(darkGray[0], darkGray[1], darkGray[2]);
    doc.text(truncatedTitle, 25, tocY);
    doc.setTextColor(mediumGray[0], mediumGray[1], mediumGray[2]);
    doc.text(`${pageNum}`, 195, tocY, { align: 'right' });
    tocY += 5;
  });
  
  // Process each post on its own page
  for (let index = 0; index < posts.length; index++) {
    const post = posts[index];
    
    // New page for each post
    doc.addPage();
    const currentPage = doc.getNumberOfPages();
    addCompactHeader(currentPage);
    
    let yPosition = 22;
    
    // Post title
    doc.setFontSize(13);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(darkGray[0], darkGray[1], darkGray[2]);
    const titleLines = doc.splitTextToSize(post.title || 'Untitled Post', 190);
    titleLines.forEach((line: string) => {
      if (yPosition > 285) {
        doc.addPage();
        addCompactHeader(doc.getNumberOfPages());
        yPosition = 22;
      }
      doc.text(line, 10, yPosition);
      yPosition += 5.5;
    });
    
    // Metadata line
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(mediumGray[0], mediumGray[1], mediumGray[2]);
    const author = post.author_name || 'Unknown';
    const postDate = post.wp_published_date ? new Date(post.wp_published_date).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    }) : 'No date';
    doc.text(`${author} | ${postDate}`, 10, yPosition);
    yPosition += 4;
    
    // Tags inline
    if (options.includeTags && post.tags && post.tags.length > 0) {
      doc.setFont('helvetica', 'italic');
      doc.setTextColor(accentBlue[0], accentBlue[1], accentBlue[2]);
      const tagsText = post.tags.slice(0, 5).join(' '); // Limit to 5 tags
      doc.text(tagsText, 10, yPosition);
      yPosition += 4;
    }
    
    // Featured image
    if (post.featured_media_url) {
      if (yPosition > 220) {
        doc.addPage();
        addCompactHeader(doc.getNumberOfPages());
        yPosition = 22;
      }
      try {
        const imageAdded = await addImageToPDF(doc, post.featured_media_url, 10, yPosition, 190);
        if (imageAdded.success) {
          yPosition = imageAdded.newY + 3;
        }
      } catch (error) {
        // Skip failed images
      }
    }
    
    // Post content
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(darkGray[0], darkGray[1], darkGray[2]);
    doc.setFontSize(9);
    
    // Parse and render HTML content
    const contentParts = await parseContentCompact(post.content || '');
    
    for (const part of contentParts) {
      if (part.type === 'text' && part.content) {
        const lines = doc.splitTextToSize(part.content, 190);
        for (const line of lines) {
          if (yPosition > 285) {
            doc.addPage();
            addCompactHeader(doc.getNumberOfPages());
            yPosition = 22;
          }
          doc.text(line, 10, yPosition);
          yPosition += 4.5;
        }
      } else if (part.type === 'image' && part.src) {
        if (yPosition > 220) {
          doc.addPage();
          addCompactHeader(doc.getNumberOfPages());
          yPosition = 22;
        }
        try {
          const imageAdded = await addImageToPDF(doc, part.src, 10, yPosition, 190);
          if (imageAdded.success) {
            yPosition = imageAdded.newY + 3;
          }
        } catch (error) {
          // Skip failed images
        }
      }
    }
    
    // Attachments - compact list
    if (post.attachments && post.attachments.length > 0) {
      if (yPosition > 270) {
        doc.addPage();
        addCompactHeader(doc.getNumberOfPages());
        yPosition = 22;
      }
      
      yPosition += 3;
      doc.setFontSize(8);
      doc.setFont('helvetica', 'bold');
      doc.text('Attachments:', 10, yPosition);
      yPosition += 3.5;
      
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      post.attachments.forEach((attachment: any) => {
        if (yPosition > 285) {
          doc.addPage();
          addCompactHeader(doc.getNumberOfPages());
          yPosition = 22;
        }
        const attachmentText = `â€¢ ${attachment.title || attachment.filename || 'File'}`;
        doc.text(attachmentText, 12, yPosition);
        yPosition += 3.5;
      });
    }
    
    // Comments - very compact
    if (options.includeComments && post.comments && post.comments.length > 0) {
      if (yPosition > 265) {
        doc.addPage();
        addCompactHeader(doc.getNumberOfPages());
        yPosition = 22;
      }
      
      yPosition += 4;
      doc.setFontSize(8);
      doc.setFont('helvetica', 'bold');
      doc.text(`Comments (${post.comments.length})`, 10, yPosition);
      yPosition += 3.5;
      
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      
      post.comments.forEach((comment: any) => {
        if (yPosition > 280) {
          doc.addPage();
          addCompactHeader(doc.getNumberOfPages());
          yPosition = 22;
        }
        
        const commentAuthor = (comment as any).author_name || (comment as any).username || 'Anonymous';
        doc.setFont('helvetica', 'bold');
        doc.text(commentAuthor + ':', 10, yPosition);
        yPosition += 3.5;
        
        doc.setFont('helvetica', 'normal');
        const commentLines = doc.splitTextToSize(comment.content || '', 185);
        commentLines.forEach((line: string) => {
          if (yPosition > 285) {
            doc.addPage();
            addCompactHeader(doc.getNumberOfPages());
            yPosition = 22;
          }
          doc.text(line, 12, yPosition);
          yPosition += 3.5;
        });
        yPosition += 2;
      });
    }
  }
  
  // Add page numbers to all pages
  const pageCount = doc.getNumberOfPages();
  doc.setFontSize(8);
  doc.setTextColor(mediumGray[0], mediumGray[1], mediumGray[2]);
  
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.text(`${i} / ${pageCount}`, 105, 295, { align: 'center' });
  }
  
  return doc;
};

// Simplified image adding function
async function addImageToPDF(doc: jsPDF, imageUrl: string, x: number, y: number, maxWidth: number) {
  try {
    const imageData = await loadImage(imageUrl);
    if (!imageData) {
      return { success: false, newY: y };
    }
    
    const aspectRatio = imageData.height / imageData.width;
    let imgWidth = Math.min(maxWidth, imageData.width * 0.264583); // Convert pixels to mm (assuming 96 DPI)
    let imgHeight = imgWidth * aspectRatio;
    
    // Limit height to prevent page overflow
    const maxHeight = 120;
    if (imgHeight > maxHeight) {
      imgHeight = maxHeight;
      imgWidth = imgHeight / aspectRatio;
    }
    
    // Check if image fits on current page
    if (y + imgHeight > 285) {
      return { success: false, newY: y };
    }
    
    doc.addImage(imageData.data, 'JPEG', x, y, imgWidth, imgHeight);
    return { success: true, newY: y + imgHeight };
  } catch (error) {
    return { success: false, newY: y };
  }
}

// Load image helper
async function loadImage(url: string): Promise<ImageInfo | null> {
  // Check cache first
  if (imageCache.has(url)) {
    return imageCache.get(url)!;
  }
  
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        resolve(null);
        return;
      }
      
      ctx.drawImage(img, 0, 0);
      const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
      
      const imageInfo = {
        width: img.width,
        height: img.height,
        data: dataUrl
      };
      
      imageCache.set(url, imageInfo);
      resolve(imageInfo);
    };
    
    img.onerror = () => resolve(null);
    
    // Set source with timeout
    img.src = url.startsWith('/') ? `${window.location.origin}${url}` : url;
    
    setTimeout(() => resolve(null), 3000);
  });
}

// Parse content for compact rendering
async function parseContentCompact(html: string): Promise<Array<{ type: 'text' | 'image'; content?: string; src?: string }>> {
  const parts: Array<{ type: 'text' | 'image'; content?: string; src?: string }> = [];
  
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = html;
  
  // Extract images
  const images = tempDiv.querySelectorAll('img');
  const imageMap = new Map<string, string>();
  
  images.forEach((img, index) => {
    const placeholder = `__IMG_${index}__`;
    const src = img.src || img.getAttribute('data-src') || '';
    if (src) {
      imageMap.set(placeholder, src);
      img.replaceWith(placeholder);
    }
  });
  
  // Get text content
  const textContent = tempDiv.innerText || tempDiv.textContent || '';
  const lines = textContent.split('\n').filter(line => line.trim());
  
  for (const line of lines) {
    if (line.includes('__IMG_')) {
      const match = line.match(/__IMG_(\d+)__/);
      if (match) {
        const placeholder = match[0];
        const src = imageMap.get(placeholder);
        
        // Add text before image
        const beforeText = line.substring(0, match.index || 0).trim();
        if (beforeText) {
          parts.push({ type: 'text', content: beforeText });
        }
        
        // Add image
        if (src) {
          parts.push({ type: 'image', src });
        }
        
        // Add text after image
        const afterText = line.substring((match.index || 0) + placeholder.length).trim();
        if (afterText) {
          parts.push({ type: 'text', content: afterText });
        }
      } else {
        parts.push({ type: 'text', content: line });
      }
    } else if (line.trim()) {
      parts.push({ type: 'text', content: line });
    }
  }
  
  // Combine consecutive text parts
  const combined: Array<{ type: 'text' | 'image'; content?: string; src?: string }> = [];
  let currentText = '';
  
  for (const part of parts) {
    if (part.type === 'text') {
      currentText += (currentText ? '\n' : '') + part.content;
    } else {
      if (currentText) {
        combined.push({ type: 'text', content: currentText });
        currentText = '';
      }
      combined.push(part);
    }
  }
  
  if (currentText) {
    combined.push({ type: 'text', content: currentText });
  }
  
  return combined;
}

export const downloadPDF = async (posts: PostWithComments[], filename?: string, options?: { includeComments?: boolean; includeTags?: boolean; user?: { username?: string; email?: string } }) => {
  const doc = await generatePDF(posts, options);
  const defaultFilename = `vector-export-${Date.now()}.pdf`;
  doc.save(filename || defaultFilename);
};