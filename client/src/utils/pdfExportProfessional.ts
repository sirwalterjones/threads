import jsPDF from 'jspdf';
import { Post } from '../types';

interface PostWithComments extends Post {
  comments?: Array<{
    content: string;
    author_name?: string;
    username?: string;
    created_at?: string;
  }>;
  // Intel Report specific fields
  intel_number?: string;
  date?: string;
  time?: string;
  incident_location?: string;
  location?: string;
  subject?: string;
  agent_name?: string;
  classification?: string;
  summary?: string;
}

export async function generateProfessionalPDF(
  posts: PostWithComments[],
  reportMetadata?: {
    reportTitle?: string;
    author?: string;
    unit?: string;
    classification?: string;
    category?: string;
    generatedBy?: string; // Who is generating the report
  }
): Promise<void> {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'in',
    format: 'letter'
  });

  // Use Courier (monospace) font for the entire document
  doc.setFont('courier', 'normal');
  
  const pageWidth = 8.5;
  const pageHeight = 11;
  const leftMargin = 0.75;
  const rightMargin = 0.75;
  const topMargin = 0.5;
  const bottomMargin = 0.75;
  const contentWidth = pageWidth - leftMargin - rightMargin;
  const headerHeight = 0.8;
  
  let currentPage = 1;
  let totalPages = 1; // Will be updated after calculating actual pages
  
  // First pass: calculate total pages needed
  posts.forEach((post) => {
    let tempY = headerHeight + 1.5; // Account for header and metadata
    
    // Account for narrative content
    const narrative = post.summary || post.content || 'No narrative available.';
    const cleanNarrative = narrative
      .replace(/<[^>]*>/g, '')
      .replace(/&nbsp;/g, ' ')
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .trim();
    
    const lines = doc.splitTextToSize(cleanNarrative, contentWidth);
    tempY += lines.length * 0.18;
    
    // Account for comments
    if (post.comments && post.comments.length > 0) {
      tempY += 0.4; // Headers
      post.comments.forEach(comment => {
        tempY += 0.15; // Comment header
        const commentLines = doc.splitTextToSize(comment.content || '', contentWidth);
        tempY += commentLines.length * 0.15 + 0.1;
      });
    }
    
    // Calculate pages needed for this post
    const pagesForPost = Math.ceil((tempY - topMargin) / (pageHeight - topMargin - bottomMargin));
    totalPages += pagesForPost - 1; // -1 because we started with 1
  });
  
  currentPage = 1;
  
  // Process each post as a separate page
  posts.forEach((post, index) => {
    if (index > 0) {
      doc.addPage();
      currentPage++;
    }
    
    // Black header background
    doc.setFillColor(0, 0, 0);
    doc.rect(0, 0, pageWidth, headerHeight, 'F');
    
    // VECTOR logo with blue V
    let yPosition = 0.3;
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    
    // Blue "V" for VECTOR
    doc.setTextColor(29, 155, 240); // Twitter/X blue
    doc.text('V', leftMargin, yPosition);
    
    // White "ECTOR" for the rest of VECTOR
    doc.setTextColor(255, 255, 255);
    const vWidth = doc.getTextWidth('V');
    doc.text('ECTOR', leftMargin + vWidth, yPosition);
    
    // Page number on the right in white
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(10);
    const pageText = `Page ${currentPage} of ${totalPages}`;
    doc.text(pageText, pageWidth - rightMargin - doc.getTextWidth(pageText), yPosition);
    
    // Classification banner below header
    yPosition = headerHeight + 0.1;
    doc.setTextColor(255, 0, 0); // Red for classification
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    const classificationText = 'LAW ENFORCEMENT SENSITIVE';
    const classWidth = doc.getTextWidth(classificationText);
    doc.text(classificationText, (pageWidth - classWidth) / 2, yPosition);
    
    yPosition += 0.3;
    
    // Report metadata section
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    
    // Report Number
    if (post.intel_number || post.id) {
      doc.setFont('helvetica', 'bold');
      doc.text('Report #:', leftMargin, yPosition);
      doc.setFont('helvetica', 'normal');
      const reportNumber = post.intel_number || `${post.id}`;
      doc.text(reportNumber, leftMargin + 1, yPosition);
    }
    
    // Generated By (right side)
    if (reportMetadata?.generatedBy) {
      doc.setFont('helvetica', 'bold');
      const genByLabel = 'Generated By:';
      const genByLabelWidth = doc.getTextWidth(genByLabel);
      doc.text(genByLabel, pageWidth - rightMargin - 2.5, yPosition);
      doc.setFont('helvetica', 'normal');
      doc.text(reportMetadata.generatedBy, pageWidth - rightMargin - 2.5 + genByLabelWidth + 0.1, yPosition);
    }
    
    yPosition += 0.2;
    
    // Date Generated
    doc.setFont('helvetica', 'bold');
    doc.text('Date:', leftMargin, yPosition);
    doc.setFont('helvetica', 'normal');
    const generatedDate = new Date().toLocaleDateString('en-US', { 
      month: 'long', 
      day: 'numeric', 
      year: 'numeric' 
    });
    doc.text(generatedDate, leftMargin + 0.5, yPosition);
    
    // Time (right side)
    doc.setFont('helvetica', 'bold');
    const timeLabel = 'Time:';
    const timeLabelWidth = doc.getTextWidth(timeLabel);
    doc.text(timeLabel, pageWidth - rightMargin - 2.5, yPosition);
    doc.setFont('helvetica', 'normal');
    const generatedTime = new Date().toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit',
      hour12: true 
    });
    doc.text(generatedTime, pageWidth - rightMargin - 2.5 + timeLabelWidth + 0.1, yPosition);
    
    yPosition += 0.25;
    
    // Main Title section
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    const mainTitle = post.intel_number || post.title || 'Intelligence Report';
    doc.text(mainTitle, leftMargin, yPosition);
    
    yPosition += 0.3;
    
    // Report content section
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    
    // Date of Report - LABEL ON ITS OWN LINE, NO COLON
    if (post.date || post.ingested_at) {
      doc.setFont('helvetica', 'bold');
      doc.text('Date of Report', leftMargin, yPosition);
      doc.setFont('helvetica', 'normal');
      yPosition += 0.15;
      const incidentDate = post.date ? 
        new Date(post.date).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) :
        new Date(post.ingested_at).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
      doc.text(incidentDate, leftMargin, yPosition);
      yPosition += 0.25; // Double space between sections
    }
    
    // Time of Report - LABEL ON ITS OWN LINE, NO COLON
    if (post.time || post.ingested_at) {
      doc.setFont('helvetica', 'bold');
      doc.text('Time of Report', leftMargin, yPosition);
      doc.setFont('helvetica', 'normal');
      yPosition += 0.15;
      const reportTime = post.time || 
        new Date(post.ingested_at).toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit',
          hour12: true 
        });
      doc.text(reportTime, leftMargin, yPosition);
      yPosition += 0.25; // Double space between sections
    }
    
    // Incident Location - LABEL ON ITS OWN LINE, NO COLON
    if (post.incident_location || post.location) {
      doc.setFont('helvetica', 'bold');
      doc.text('Incident Location', leftMargin, yPosition);
      doc.setFont('helvetica', 'normal');
      yPosition += 0.15;
      const location = post.incident_location || post.location || 'Not specified';
      const locationLines = doc.splitTextToSize(location, contentWidth);
      
      // Print location lines
      locationLines.forEach((line: string) => {
        doc.text(line, leftMargin, yPosition);
        yPosition += 0.15;
      });
      yPosition += 0.1; // Extra space after location
    }
    
    // Report Title - ON SAME LINE - REMOVE COLON AND BOLD
    if (post.subject || post.title) {
      doc.setFont('helvetica', 'bold');
      doc.text('Report Title', leftMargin, yPosition);
      doc.setFont('helvetica', 'normal');
      yPosition += 0.15; // Move to next line
      doc.text(post.subject || post.title || 'Untitled', leftMargin, yPosition);
      yPosition += 0.25; // Double space before next section
    }
    
    // Narrative section - BOLD, NO COLON
    doc.setFont('helvetica', 'bold');
    doc.text('Narrative', leftMargin, yPosition);
    yPosition += 0.15;
    
    // Narrative content
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    
    const narrative = post.summary || post.content || 'No narrative available.';
    // Clean up HTML if present
    const cleanNarrative = narrative
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&nbsp;/g, ' ')  // Replace HTML spaces
      .replace(/&amp;/g, '&')   // Replace HTML ampersand
      .replace(/&lt;/g, '<')    // Replace HTML less than
      .replace(/&gt;/g, '>')    // Replace HTML greater than
      .replace(/&quot;/g, '"')  // Replace HTML quotes
      .replace(/&#39;/g, "'")   // Replace HTML apostrophe
      .trim();
    
    const lines = doc.splitTextToSize(cleanNarrative, contentWidth);
    
    lines.forEach((line: string) => {
      if (yPosition > pageHeight - bottomMargin - 0.5) {
        // Add footer before page break
        addFooter(doc, currentPage);
        
        doc.addPage();
        currentPage++;
        yPosition = topMargin;
        
        // Repeat header on new page
        addHeader(doc, currentPage, totalPages);
        yPosition = headerHeight + 0.5;
      }
      
      doc.text(line, leftMargin, yPosition);
      yPosition += 0.18;
    });
    
    // Add comments if they exist
    if (post.comments && post.comments.length > 0) {
      yPosition += 0.2;
      
      if (yPosition < pageHeight - bottomMargin - 1) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(11);
        doc.text('ADDITIONAL NOTES', leftMargin, yPosition);
        yPosition += 0.2;
        
        post.comments.forEach(comment => {
          if (yPosition > pageHeight - bottomMargin - 0.5) {
            addFooter(doc, currentPage);
            doc.addPage();
            currentPage++;
            addHeader(doc, currentPage, totalPages);
            yPosition = headerHeight + 0.5;
          }
          
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(10);
          const commentAuthor = comment.author_name || comment.username || 'Unknown';
          const commentDate = comment.created_at ? 
            new Date(comment.created_at).toLocaleDateString() : '';
          doc.text(`${commentAuthor} - ${commentDate}:`, leftMargin, yPosition);
          yPosition += 0.15;
          
          doc.setFont('helvetica', 'normal');
          const commentLines = doc.splitTextToSize(comment.content || '', contentWidth);
          commentLines.forEach((line: string) => {
            if (yPosition > pageHeight - bottomMargin - 0.5) {
              addFooter(doc, currentPage);
              doc.addPage();
              currentPage++;
              addHeader(doc, currentPage, totalPages);
              yPosition = headerHeight + 0.5;
            }
            doc.text(line, leftMargin, yPosition);
            yPosition += 0.15;
          });
          yPosition += 0.1;
        });
      }
    }
    
    // Add footer to current page
    addFooter(doc, currentPage);
  });
  
  // Save the PDF
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = reportMetadata?.reportTitle ? 
    `${reportMetadata.reportTitle.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.pdf` :
    `intel_report_${timestamp}.pdf`;
  
  doc.save(filename);
}

function addHeader(doc: jsPDF, pageNum: number, totalPages: number) {
  const pageWidth = 8.5;
  const leftMargin = 0.75;
  const rightMargin = 0.75;
  const headerHeight = 0.8;
  
  // Black header background
  doc.setFillColor(0, 0, 0);
  doc.rect(0, 0, pageWidth, headerHeight, 'F');
  
  // VECTOR logo with blue V
  const yPosition = 0.3;
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  
  // Blue "V"
  doc.setTextColor(29, 155, 240);
  doc.text('V', leftMargin, yPosition);
  
  // White "ECTOR"
  doc.setTextColor(255, 255, 255);
  const vWidth = doc.getTextWidth('V');
  doc.text('ECTOR', leftMargin + vWidth, yPosition);
  
  // Page number
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(10);
  const pageText = `Page ${pageNum} of ${totalPages}`;
  doc.text(pageText, pageWidth - rightMargin - doc.getTextWidth(pageText), yPosition);
}

function addFooter(doc: jsPDF, pageNum: number) {
  const pageWidth = 8.5;
  const pageHeight = 11;
  const leftMargin = 0.75;
  const rightMargin = 0.75;
  const bottomMargin = 0.5;
  
  // Footer line
  doc.setLineWidth(0.005);
  doc.setDrawColor(200, 200, 200);
  doc.line(leftMargin, pageHeight - bottomMargin - 0.2, pageWidth - rightMargin, pageHeight - bottomMargin - 0.2);
  
  // Footer text
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  
  // Left side - Law Enforcement Sensitive
  const footerLeft = 'Law Enforcement Sensitive - Do Not Release';
  doc.text(footerLeft, leftMargin, pageHeight - bottomMargin);
  
  // Right side - Cherokee Sheriff's Office
  const footerRight = 'Cherokee Sheriff\'s Office Intelligence Division';
  doc.text(footerRight, pageWidth - rightMargin - doc.getTextWidth(footerRight), pageHeight - bottomMargin);
}

// Wrapper function for backward compatibility
export const downloadPDF = async (
  posts: PostWithComments[], 
  filename?: string, 
  options?: { 
    includeComments?: boolean; 
    includeTags?: boolean; 
    user?: { username?: string; email?: string } 
  }
) => {
  const reportMetadata = {
    reportTitle: filename?.replace('.pdf', '') || 'Intelligence Report',
    author: options?.user?.username || 'Unknown',
    unit: 'Cherokee Sheriff\'s Office Intelligence Division',
    classification: 'Law Enforcement Sensitive',
    category: 'Intelligence Report',
    generatedBy: options?.user?.username || 'System'
  };
  
  return generateProfessionalPDF(posts, reportMetadata);
};

// Export default for backward compatibility
export default { generateProfessionalPDF, downloadPDF };